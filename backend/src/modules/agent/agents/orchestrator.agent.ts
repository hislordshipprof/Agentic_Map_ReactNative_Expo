/**
 * Orchestrator Agent - LLM-driven workflow orchestration
 *
 * This is the "brain" of the agentic system. Instead of hardcoded flows,
 * the LLM decides which tools to call based on the user's intent.
 *
 * Similar to how Grok uses tools "in tandem" for Tesla navigation.
 */

import { Injectable, Logger } from '@nestjs/common';
import { ToolRegistry, ToolResult, BUILT_IN_TOOLS } from '../tools/tool-registry';
import { ContextManagerService } from '../context/context-manager.service';
import { UnderstandingAgent, UnderstandingResult } from './understanding.agent';
import { ConversationContext } from '../context/conversation-context';
import { GeminiClient } from '../llm/gemini-client';

/**
 * A single step in an execution plan
 */
export interface PlanStep {
  stepNumber: number;
  tool: string;
  params: Record<string, unknown>;
  reasoning: string;
  dependsOn?: number[]; // Step numbers this depends on
}

/**
 * Execution plan generated by the orchestrator
 */
export interface ExecutionPlan {
  goal: string;
  steps: PlanStep[];
  estimatedSteps: number;
}

/**
 * Result of orchestrator processing
 */
export interface OrchestratorResult {
  // Overall status
  success: boolean;
  completed: boolean;

  // What was accomplished
  intent?: string;
  action?: string;

  // Route data (if route was planned)
  route?: {
    id: string;
    origin: { name: string; location: { lat: number; lng: number } };
    destination: { name: string; location: { lat: number; lng: number } };
    stops: Array<{ name: string; location: { lat: number; lng: number } }>;
    totalTime: number;
    totalDistance: number;
    polyline: string;
  };

  // Response to speak to user
  response?: string;

  // If user input is needed
  needsUserInput?: boolean;
  clarificationQuestion?: string;
  clarificationOptions?: string[];

  // Execution trace (for debugging)
  trace: Array<{
    step: number;
    tool: string;
    params: Record<string, unknown>;
    result: ToolResult;
    timestamp: number;
  }>;

  // Errors
  error?: string;
}

/**
 * System prompt for the orchestrator
 */
const ORCHESTRATOR_SYSTEM_PROMPT = `You are a navigation assistant orchestrator. Your job is to:
1. Analyze the user's request and conversation context
2. Decide which tools to call to fulfill the request
3. Execute the tools in the correct order
4. Generate a helpful response

Available tools:
{TOOLS}

Guidelines:
- Always resolve anchors (home, work) before searching for places
- Search for places near the route corridor when adding stops
- Calculate detours before confirming significant additions
- Ask the user if a detour is too long (>10 minutes)
- Generate natural, conversational responses

Response format:
Return a JSON object with:
{
  "reasoning": "Brief explanation of your plan",
  "steps": [
    { "tool": "tool_name", "params": { ... } }
  ]
}`;

@Injectable()
export class OrchestratorAgent {
  private readonly logger = new Logger(OrchestratorAgent.name);
  private readonly gemini: GeminiClient;

  constructor(
    private readonly toolRegistry: ToolRegistry,
    private readonly contextManager: ContextManagerService,
    private readonly understandingAgent: UnderstandingAgent,
  ) {
    this.gemini = new GeminiClient();
    this.registerBuiltInTools();
  }

  /**
   * Register all built-in tools
   */
  private registerBuiltInTools(): void {
    // Tools will be registered by the AgentModule during initialization
    // This is just a placeholder for the definitions
    for (const toolDef of BUILT_IN_TOOLS) {
      this.logger.debug(`Tool definition available: ${toolDef.name}`);
    }
  }

  /**
   * Process a user request through the full agentic pipeline
   */
  async processRequest(
    sessionId: string,
    utterance: string,
    userLocation?: { lat: number; lng: number },
  ): Promise<OrchestratorResult> {
    const trace: OrchestratorResult['trace'] = [];
    const startTime = Date.now();

    this.logger.log(`Processing request for session ${sessionId}: "${utterance}"`);

    try {
      // Update user location if provided
      if (userLocation) {
        this.contextManager.updateUserLocation(sessionId, userLocation);
      }

      // Step 1: Understand the utterance
      const understanding = await this.understandingAgent.processUtterance(sessionId, utterance);

      // If clarification needed, return early
      if (understanding.clarificationNeeded) {
        return {
          success: true,
          completed: false,
          intent: understanding.intent,
          needsUserInput: true,
          clarificationQuestion: understanding.clarificationQuestion,
          clarificationOptions: understanding.clarificationOptions,
          trace,
        };
      }

      // Step 2: Generate execution plan
      const context = this.contextManager.getOrCreateContext(sessionId);
      const plan = await this.generatePlan(understanding, context, userLocation);

      if (!plan || plan.steps.length === 0) {
        return {
          success: true,
          completed: true,
          intent: understanding.intent,
          response: this.generateFallbackResponse(understanding),
          trace,
        };
      }

      // Step 3: Execute the plan
      const executionResult = await this.executePlan(sessionId, plan, trace);

      // Step 4: Generate final response
      const response = await this.generateFinalResponse(
        understanding,
        executionResult,
        context,
      );

      // Record assistant turn
      this.contextManager.recordAssistantTurn(
        sessionId,
        response,
        trace.map((t) => ({ tool: t.tool, params: t.params, result: t.result })),
        executionResult.routeId,
      );

      const result: OrchestratorResult = {
        success: true,
        completed: !executionResult.needsUserInput,
        intent: understanding.intent,
        action: plan.goal,
        response,
        trace,
      };

      // Add route if one was planned
      if (executionResult.route) {
        result.route = executionResult.route;
      }

      // Add clarification if needed
      if (executionResult.needsUserInput) {
        result.needsUserInput = true;
        result.clarificationQuestion = executionResult.question;
        result.clarificationOptions = executionResult.options;
      }

      this.logger.log(`Request processed in ${Date.now() - startTime}ms`);
      return result;

    } catch (error) {
      this.logger.error('Orchestrator error:', error);
      return {
        success: false,
        completed: false,
        error: error instanceof Error ? error.message : 'Processing failed',
        response: "I'm sorry, something went wrong. Could you try again?",
        trace,
      };
    }
  }

  /**
   * Generate an execution plan based on understanding
   */
  private async generatePlan(
    understanding: UnderstandingResult,
    context: ConversationContext,
    userLocation?: { lat: number; lng: number },
  ): Promise<ExecutionPlan | null> {
    // For simple intents, use predefined plans
    const simplePlan = this.getSimplePlan(understanding, context, userLocation);
    if (simplePlan) {
      return simplePlan;
    }

    // For complex requests, use LLM to generate plan
    return this.generateLlmPlan(understanding, context, userLocation);
  }

  /**
   * Get a simple predefined plan for common intents
   */
  private getSimplePlan(
    understanding: UnderstandingResult,
    context: ConversationContext,
    userLocation?: { lat: number; lng: number },
  ): ExecutionPlan | null {
    const { intent, entities } = understanding;

    switch (intent) {
      case 'navigate_with_stops':
      case 'navigate_direct':
        return this.createNavigationPlan(entities, context, userLocation);

      case 'add_stop':
        return this.createAddStopPlan(entities, context, userLocation);

      case 'remove_stop':
        return this.createRemoveStopPlan(entities, context);

      case 'confirm':
        return this.createConfirmPlan(context);

      case 'cancel':
        return this.createCancelPlan(context);

      default:
        return null;
    }
  }

  /**
   * Known anchor keywords (user's saved locations)
   */
  private readonly ANCHOR_KEYWORDS = ['home', 'work', 'office', 'house', 'apartment'];

  /**
   * Check if a destination is an anchor (saved location) or a place to search
   */
  private isAnchor(name: string): boolean {
    const lower = name.toLowerCase().trim();
    return this.ANCHOR_KEYWORDS.some((kw) => lower.includes(kw));
  }

  /**
   * Create a navigation plan
   */
  private createNavigationPlan(
    entities: Record<string, unknown> | undefined,
    context: ConversationContext,
    userLocation?: { lat: number; lng: number },
  ): ExecutionPlan {
    const steps: PlanStep[] = [];
    let stepNum = 1;

    const destination = entities?.destination as string | undefined;
    const stops = (entities?.stops as string[] | undefined) || [];

    // Get user location - required for all navigation tools
    const location = userLocation || context.userLocation;

    this.logger.log(`Creating navigation plan: destination="${destination}", stops=${JSON.stringify(stops)}, location=${location ? `${location.lat},${location.lng}` : 'none'}`);

    if (!location) {
      this.logger.warn('No user location available for navigation plan');
    }

    // Step 1: Handle destination
    if (destination) {
      if (this.isAnchor(destination)) {
        // It's an anchor like "home" or "work" - resolve from saved locations
        steps.push({
          stepNumber: stepNum++,
          tool: 'resolve_anchor',
          params: {
            anchor_name: destination,
            user_location: location,
            user_anchors: [], // TODO: Get from user settings
          },
          reasoning: `Resolve "${destination}" to saved address`,
        });
      } else {
        // It's a place like "Walmart" - search for it
        steps.push({
          stepNumber: stepNum++,
          tool: 'search_places',
          params: {
            query: destination,
            location: location,
            max_results: 1, // Just need the best match for destination
          },
          reasoning: `Find "${destination}" near you`,
        });
      }
    }

    // Step 2: Search for each stop
    for (const stop of stops) {
      steps.push({
        stepNumber: stepNum++,
        tool: 'search_places',
        params: {
          query: stop,
          location: location,
          max_results: 3,
        },
        reasoning: `Find ${stop} options along the route`,
      });
    }

    // Calculate route - depends on ALL previous steps (destination + stops resolution)
    const previousStepNumbers = steps.map((s) => s.stepNumber);
    steps.push({
      stepNumber: stepNum++,
      tool: 'calculate_route',
      params: {
        origin: location,
        destination: { name: destination || 'home' },
        waypoints: stops,
        user_anchors: [], // TODO: Get from user settings
      },
      reasoning: 'Calculate the full route with stops',
      dependsOn: previousStepNumbers.length > 0 ? previousStepNumbers : undefined,
    });

    // Step 4: Generate response
    steps.push({
      stepNumber: stepNum++,
      tool: 'generate_response',
      params: {
        message_type: 'route_summary',
        content: { destination, stops },
      },
      reasoning: 'Generate a natural response about the route',
      dependsOn: [stepNum - 1],
    });

    return {
      goal: `Navigate to ${destination}${stops.length > 0 ? ` with stops at ${stops.join(', ')}` : ''}`,
      steps,
      estimatedSteps: steps.length,
    };
  }

  /**
   * Create plan to add a stop to existing route
   */
  private createAddStopPlan(
    entities: Record<string, unknown> | undefined,
    context: ConversationContext,
    userLocation?: { lat: number; lng: number },
  ): ExecutionPlan {
    const stops = (entities?.stops as string[] | undefined) || [];
    const steps: PlanStep[] = [];
    let stepNum = 1;

    // Search for the stop
    for (const stop of stops) {
      steps.push({
        stepNumber: stepNum++,
        tool: 'search_places',
        params: {
          query: stop,
          location: userLocation || context.userLocation,
          route_context: context.currentRoute
            ? {
                origin: context.currentRoute.origin.location,
                destination: context.currentRoute.destination.location,
              }
            : undefined,
        },
        reasoning: `Find ${stop} along the current route`,
      });
    }

    // Calculate detour
    steps.push({
      stepNumber: stepNum++,
      tool: 'calculate_detour',
      params: {
        current_route: context.currentRoute,
        new_stop: { name: stops[0] }, // Primary stop as object
      },
      reasoning: 'Check how much time this stop adds',
      dependsOn: [1],
    });

    return {
      goal: `Add ${stops.join(' and ')} to the current route`,
      steps,
      estimatedSteps: steps.length,
    };
  }

  /**
   * Create plan to remove a stop
   */
  private createRemoveStopPlan(
    entities: Record<string, unknown> | undefined,
    context: ConversationContext,
  ): ExecutionPlan {
    const stops = (entities?.stops as string[] | undefined) || [];

    return {
      goal: `Remove ${stops.join(' and ')} from the route`,
      steps: [
        {
          stepNumber: 1,
          tool: 'confirm_action',
          params: {
            action: `Remove ${stops.join(' and ')} from your route?`,
          },
          reasoning: 'Confirm before removing stops',
        },
      ],
      estimatedSteps: 1,
    };
  }

  /**
   * Create plan to confirm current route
   */
  private createConfirmPlan(context: ConversationContext): ExecutionPlan {
    return {
      goal: 'Start navigation',
      steps: [
        {
          stepNumber: 1,
          tool: 'start_navigation',
          params: {
            route_id: context.currentRoute?.routeId || 'pending',
          },
          reasoning: 'Start navigation for confirmed route',
        },
      ],
      estimatedSteps: 1,
    };
  }

  /**
   * Create plan to cancel current operation
   */
  private createCancelPlan(context: ConversationContext): ExecutionPlan {
    return {
      goal: 'Cancel current operation',
      steps: [
        {
          stepNumber: 1,
          tool: 'generate_response',
          params: {
            message_type: 'info',
            content: { message: 'Route cancelled' },
          },
          reasoning: 'Acknowledge cancellation',
        },
      ],
      estimatedSteps: 1,
    };
  }

  /**
   * Generate a plan using LLM for complex requests
   */
  private async generateLlmPlan(
    understanding: UnderstandingResult,
    context: ConversationContext,
    userLocation?: { lat: number; lng: number },
  ): Promise<ExecutionPlan | null> {
    const toolsDescription = this.toolRegistry.getToolsDescription();
    const contextSummary = this.contextManager.getContextSummary(context.sessionId);

    const prompt = ORCHESTRATOR_SYSTEM_PROMPT.replace('{TOOLS}', toolsDescription) +
      `\n\nConversation context:\n${contextSummary}\n\n` +
      `User's intent: ${understanding.intent}\n` +
      `Entities: ${JSON.stringify(understanding.entities)}\n` +
      `User location: ${userLocation ? JSON.stringify(userLocation) : 'unknown'}\n\n` +
      `Generate a plan to fulfill this request:`;

    try {
      const response = await this.gemini.generate(prompt);

      // Extract JSON from response (may be wrapped in markdown code blocks)
      let jsonStr = response;
      const jsonMatch = response.match(/```(?:json)?\s*([\s\S]*?)```/);
      if (jsonMatch) {
        jsonStr = jsonMatch[1].trim();
      }

      const parsed = JSON.parse(jsonStr);

      return {
        goal: parsed.reasoning || understanding.intent || 'Process request',
        steps: parsed.steps.map((s: { tool: string; params: Record<string, unknown> }, i: number) => ({
          stepNumber: i + 1,
          tool: s.tool,
          params: s.params,
          reasoning: '',
        })),
        estimatedSteps: parsed.steps.length,
      };
    } catch (error) {
      this.logger.warn('Failed to generate LLM plan, using fallback:', error);
      return null;
    }
  }

  /**
   * Execute a plan step by step
   */
  private async executePlan(
    sessionId: string,
    plan: ExecutionPlan,
    trace: OrchestratorResult['trace'],
  ): Promise<{
    routeId?: string;
    route?: OrchestratorResult['route'];
    needsUserInput?: boolean;
    question?: string;
    options?: string[];
  }> {
    const results: Map<number, ToolResult> = new Map();
    let routeId: string | undefined;
    let route: OrchestratorResult['route'] | undefined;

    for (const step of plan.steps) {
      // Check dependencies
      if (step.dependsOn) {
        const depsFailed = step.dependsOn.some((dep) => {
          const depResult = results.get(dep);
          return !depResult?.success;
        });
        if (depsFailed) {
          this.logger.warn(`Skipping step ${step.stepNumber} due to failed dependencies`);
          continue;
        }
      }

      // Execute the tool
      this.logger.log(`Executing step ${step.stepNumber}: ${step.tool}`);
      const result = await this.toolRegistry.execute(step.tool, step.params);

      // Log result
      if (result.success) {
        this.logger.log(`Step ${step.stepNumber} (${step.tool}) succeeded`);
      } else {
        this.logger.warn(`Step ${step.stepNumber} (${step.tool}) failed: ${result.error}`);
      }

      // Record in trace
      trace.push({
        step: step.stepNumber,
        tool: step.tool,
        params: step.params,
        result,
        timestamp: Date.now(),
      });

      results.set(step.stepNumber, result);

      // Handle special results
      if (result.needsUserInput) {
        return {
          needsUserInput: true,
          question: result.question,
          options: result.options,
        };
      }

      // Extract route data if this was a route calculation
      if (step.tool === 'calculate_route' && result.success && result.data) {
        const routeData = result.data as OrchestratorResult['route'] & { id: string };
        routeId = routeData.id;
        route = routeData;

        // Store route in context
        this.contextManager.setCurrentRoute(sessionId, {
          routeId: routeData.id,
          origin: routeData.origin,
          destination: routeData.destination,
          stops: routeData.stops.map((s) => ({
            id: `stop_${Date.now()}`,
            name: s.name,
            category: 'stop',
            location: s.location,
          })),
          totalTime: routeData.totalTime,
          totalDistance: routeData.totalDistance,
        });
      }
    }

    return { routeId, route };
  }

  /**
   * Generate final response based on execution results
   */
  private async generateFinalResponse(
    understanding: UnderstandingResult,
    executionResult: { route?: OrchestratorResult['route']; routeId?: string },
    context: ConversationContext,
  ): Promise<string> {
    // If we have a route, generate a conversational route summary
    if (executionResult.route) {
      const { route } = executionResult;
      const stops = route.stops.map((s) => s.name).join(' and ');

      // totalTime might be in seconds (from Google) or minutes - handle both
      const rawTime = route.totalTime || 0;
      const timeMinutes = rawTime > 300 ? Math.round(rawTime / 60) : Math.round(rawTime);

      // Format time naturally
      const timeText = timeMinutes <= 1
        ? 'just a minute'
        : timeMinutes < 60
          ? `about ${timeMinutes} minutes`
          : `about ${Math.round(timeMinutes / 60)} hour${timeMinutes >= 90 ? 's' : ''}`;

      if (route.stops.length > 0) {
        return `Got it! I found ${route.destination.name} with a stop at ${stops}. ` +
          `It'll take ${timeText}. Want me to start navigation?`;
      } else {
        return `Perfect! ${route.destination.name} is ${timeText} away. Ready when you are!`;
      }
    }

    // Generate based on intent
    return this.generateFallbackResponse(understanding);
  }

  /**
   * Generate a fallback response when no specific action was taken
   */
  private generateFallbackResponse(understanding: UnderstandingResult): string {
    const destination = understanding.entities?.destination as string | undefined;

    switch (understanding.intent) {
      case 'navigate_direct':
      case 'navigate_with_stops':
        // Navigation intent but couldn't plan a route
        if (destination) {
          return `Hmm, I'm having trouble finding ${destination}. Could you try saying it again?`;
        }
        return 'Sure! Where are we headed?';

      case 'add_stop':
        return 'What would you like to add along the way?';

      case 'confirm':
        return "Alright, let's go! Starting navigation.";

      case 'cancel':
        return 'No problem, I cancelled that. Where to instead?';

      case 'help':
        return 'Just tell me where you want to go! Like "take me to Starbucks" or "head home".';

      case 'find_place':
      case 'search':
        return 'What are you looking for nearby?';

      case 'greeting':
        return "Hey! I'm ready to help you navigate. Where would you like to go?";

      case 'unknown':
        return "Sorry, I didn't quite get that. Try saying something like 'take me to the airport'.";

      default:
        return "I'm here to help with directions! Just tell me your destination.";
    }
  }
}
